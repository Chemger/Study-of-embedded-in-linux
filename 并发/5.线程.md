# 线程

## 1. 问题的引入

前面讲到, 为了并发执行, 现在操作系统引入了"进程"概念

分析

1. 创建一个进程的开销比较大, 为什么?

   子进程要拷贝父进程的整个进程地址空间

2. 进程间的通信, 需要用到第三方 (如文件, 内核)

   也有一定的开销

于是, 就有人提出能不能在**同一个进程内部**实现任务的并发执行呢?

<b style="color:#113366;font-size:28px">线程</b>

## 2. 线程thread

线程是比进程更小的活动单位, 它是进程中的一个执行分支

进程内部可以有多个线程, 他们并发执行, 但是进程内部所有的线程**共享整个进程地址空间**

线程间的通信十分方便(相比于进程间)

因为多个线程间共享进程地址空间



自从有了线程, <b style="color:#993399;font-size:20px">线程成为了系统调度的最小单位</b>

**资源分配的单位还是进程**

线程状态图: 和进程一样

***

线程是进程内部的一个执行分支, 多个线程就是多个指令的并发执行

一般我们把`main()`函数这条分支叫做**主线程**

如果要新建另外的线程, 那么必须要指定它要执行的指令(**而指令必须要写在函数内部**)

必须要指令线程 要执行的函数

```c
main(){
 ...   
}

func(){
    
}

func1(){
    
}

func2(){

}
```

这个函数称之为**线程函数: **

新线程创建好之后, 要执行的指令都在这个函数里面



为了区分线程函数和普通函数, 线程函数的原型一般为:

```c
//原型
void *func_name(void *arg);
//如
void *myThread(void *arg){
	...
    ...
}
```

线程的实现有多种, 比较常用的是 posix 线程

`Pthread`

## 3. Linux中pthread的API

### pthread_create 创建一个线程

线程和进程一样, 有一个id, 称之为线程id, 一般用来tid 表示, 用来唯一标识一个线程

tid的类型用pthread_t来描述



线程属性:

线程栈空间的大小: 用来存放局部变量的, 决定递归的深度

线程的优先级



在pthread中, 线程属于结构体 pthread_attr_t 来描述

同时提供了一些函数用于修改线程属性, **建议程序员不要直接去修改结构体**

```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);

//thread: pthread_t的指针, 指向的地址用来保存线程id
//attr: 线程属性, 一般采取默认属性, 为NULL即可
//start_routine: 函数指针, 指向的函数就是线程函数
//arg: 线程函数的参数
//返回值: 成功返回0, 失败返回除了0之外的任意值
```
### 线程退出

1. 线程函数结束

2. 在线程执行的任意时刻, 调用`pthread_exit()`

   `void pthread_exit(void *retval);`
   retval: 退出码

3. 被别人"取消"

   其他线程调用 `pthread_cancel`

   t1执行`pthread_cancel(t2)`退出进程t2

   t2如果有个**不可被取消**的属性, 就不能被取消



这个是否可以被取消属性, 可用pthread提供的一个接口去修改它

`pthread_setcancelstate`

`int pthread_setcancelstate(int state, int *oldstate);`

state: 

> PTHREAD_CANCEL_ENABLE
>
> PTHREAD_CANCEL_DISABLE

### 回收线程资源

```c
pthread_join(pthread_t thread, void **retval);
//thread: 线程id, 表示要等待的那个线程
//retval: 二级指针, 用来保存线程的退出码
```

如果有个线程没有被其他线程join, 那么它的资源是否会被自动回收呢?

> 不一定, 取决于它的一个属性: datech 分离属性
>
> ENABLE: 分离	该线程结束, 它的资源会自动回收
>
> DISABLE: 非分离	(默认属性) 该线程结束, 它的资源不会自动回收

### 设置分离属性

pthread_datech

```t
int pthread_datech(pthread_t thread);
```

一般是自己设置自己的分离属性, 如果别人设置, 可能别人还没设置完, 我就结束了

pthread_datech(pthread_self());