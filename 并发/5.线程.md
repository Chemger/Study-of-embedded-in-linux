# 线程

## 1. 问题的引入

前面讲到, 为了并发执行, 现在操作系统引入了"进程"概念

分析

1. 创建一个进程的开销比较大, 为什么?

   子进程要拷贝父进程的整个进程地址空间

2. 进程间的通信, 需要用到第三方 (如文件, 内核)

   也有一定的开销

于是, 就有人提出能不能在**同一个进程内部**实现任务的并发执行呢?

<b style="color:#113366;font-size:28px">线程</b>

## 2. 线程thread

线程是比进程更小的活动单位, 它是进程中的一个执行分支

进程内部可以有多个线程, 他们并发执行, 但是进程内部所有的线程**共享整个进程地址空间**

线程间的通信十分方便(相比于进程间)

因为多个线程间共享进程地址空间



自从有了线程, <b style="color:#993399;font-size:20px">线程成为了系统调度的最小单位</b>

**资源分配的单位还是进程**

线程状态图: 和进程一样

***

线程是进程内部的一个执行分支, 多个线程就是多个指令的并发执行

一般我们把`main()`函数这条分支叫做**主线程**

如果要新建另外的线程, 那么必须要指定它要执行的指令(**而指令必须要写在函数内部**)

必须要指令线程 要执行的函数

```c
main(){
 ...   
}

func(){
    
}

func1(){
    
}

func2(){

}
```

这个函数称之为**线程函数: **

新线程创建好之后, 要执行的指令都在这个函数里面



为了区分线程函数和普通函数, 线程函数的原型一般为:

```c
//原型
void *func_name(void *arg);
//如
void *myThread(void *arg){
	...
    ...
}
```

线程的实现有多种, 比较常用的是 posix 线程

`Pthread`

## 3. Linux中pthread的API

### pthread_create 创建一个线程

线程和进程一样, 有一个id, 称之为线程id, 一般用来tid 表示, 用来唯一标识一个线程

tid的类型用pthread_t来描述



线程属性:

线程栈空间的大小: 用来存放局部变量的, 决定递归的深度

线程的优先级



在pthread中, 线程属于结构体 pthread_attr_t 来描述

同时提供了一些函数用于修改线程属性, **建议程序员不要直接去修改结构体**

```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);

//thread: pthread_t的指针, 指向的地址用来保存线程id
//attr: 线程属性, 一般采取默认属性, 为NULL即可
//start_routine: 函数指针, 指向的函数就是线程函数
//arg: 线程函数的参数
//返回值: 成功返回0, 失败返回除了0之外的任意值
```
