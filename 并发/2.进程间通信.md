# 进程间通信

## 1. 进程间通信(IPC) Inter process communication

**本质**：信息的交流，数据的交换

不同进程间如何通信？

1. 毫无关系的两个/多个进程
2. 有"亲缘关系"的两个/多个进程

**全局变量**不行，因为不同的进程是不同的地址空间

可以通过**文件通信**，文件是各个进程都可以访问的地方

```mermaid
graph LR
A[进程A] --->|写| B[文件] --->|读| C[进程B]
```

但是通过文件通信有一定的缺陷，比如

**无法实时同步**

**访问速度慢**

***

## 2. 管道

管道是一个**特殊的文件**

管道文件的内容**不是存在文件系统中**，而是存在**OS内核中**

<img src="D:\linux\share\CHEMGER_钱忱奥\2阶段\2.并发\2.进程间通信\3.图示\进程地址空间和内核地址空间.png" alt="进程地址空间和内核地址空间" style="zoom:200%;" />

管道可以像操作普通文件一样操作这种特殊文件	管道文件

相对普通文件的优点：**读写速度快**

管道分为**无名管道**和**有名管道**两种

### 无名管道 PIPE

在文件系统中没有名字，文件内容存在内核中

因为没名字，所有不能用open函数打开，但后续又需要对它进行**读写操作**(读写操作需要文件描述符)，文件描述符如何得到呢？



**无名管道在创建的时候就会返回文件描述符**



**创建无名管道pipe**

```c
#include<unistd.h>

int pipe(int pipefd[2]);
	//pipefd: 是一个指针，数组首地址，数组元素用来保存无名管道的文件描述符
        //pipefd[0] = 读文件描述符
		//pipefd[1] = 写文件描述符
	//返回值
		//成功返回0，失败返回-1，同时errno被设置
```

**pipe 特性**

1. pipe有两端，一端用来读，一端用来写
2. 按顺序读，读走一个数据就少一个数据
3. 不支持`lseek()`定位
4. pipe随内核持续性

> 单工		数据只能由一方A到另一方B
>
> 半双工	数据可以由A到B，也可以由B到A，但不能同时进行
>
> 全双工	数据可以由A到B，也可以由B到A，且可以同时进行

pipe本身是全双工的，但是两个进程用一个管道去实现全双工，必须要“同步”，如果不同步，就可能会读到自己所写入的数据

通常在项目中，一般会用两个管道

管道1	进程A写，进程B读

管道2	进程B写，进程A读

![管道通信](D:\linux\share\CHEMGER_钱忱奥\2阶段\2.并发\2.进程间通信\3.图示\管道通信.png)

思考：

==**无名管道可以用于任意进程间通信吗？？·**==

不行，因为无名管道没有名字，无法告知对方进程我方用的是哪个管道

但是可以用于有亲缘关系的进程间通信

因为子进程复制了父进程的文件描述符(**包括管道文件的描述符**)

### 有名管道 FIFO

在文件系统中有名字，文件内容存在内核中

fifo相对于pipe而言在文件系统中有一个文件(包含路径)

意味着**可以像普通文件一样，用open函数去获取它的文件描述**，可用于任意两个进程间通信

其他的和pipe相同



如果想实现全双工，一般也用两个管道

```c
#include<sys/types.h>
#include<sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
//mkfifo用来创建一个有名管道，这是一个特殊的文件
//内容存在内核中，只不过在文件系统中有个名字
//pathname: 要创建的有名管道在文件系统中的文件名
	//如: home/china/fifo1
	//不能放在共享文件夹中
//mode: 权限，有两种方式指定
	//宏指定
	//八进制数字
//返回值: 
	//成功返回0，失败返回-1，同时errno被设置
```

创建成功后，就有了有名管道，需要通信的进程就可以操作它了

在数据交换前，fifo的两端（read和write）**必须都被打开**

通常情况下，打开fifo的一端，另一端会**阻塞**，直到另一端也打开



一个进程也可以用**非阻塞（O_NONBLOCK）的方式打开**

在这种情况下，读写打开总会成功，即使写端没打开

==**但是只写打开会失败**==，并且errno == EEXIST， 除非读端打开

## 3. 信号

信号是进程间通信的一种方式，这种方式只是在进程间传递一个**整数**

不同的整数代表不同的信号（这个整数一般称之为信号值）

> kill -9 pid

不同的信号代表不同的含义，由信号的设置者解释

<pre>       信号         	 值      动作       说明
       ─────────────────────────────────────────────────────────────────────
       <b>SIGHUP</b>        1       A     在控制终端上是挂起信号, 或者控制进程结束
       <b>SIGINT</b>        2       A     从键盘输入的中断
       <b>SIGQUIT</b>       3       C     从键盘输入的退出
       <b>SIGILL</b>        4       C     无效硬件指令
       <b>SIGABRT</b>       6       C     非正常终止, 可能来自 <u style="text-decoration-style:single">abort</u>(3)
       <b>SIGFPE</b>        8       C     浮点运算例外
       <b>SIGKILL</b>       9      AEF    杀死进程信号
       <b>SIGSEGV</b>      11       C     无效的内存引用
       <b>SIGPIPE</b>      13       A     管道中止: 写入无人读取的管道
       <b>SIGALRM</b>      14       A     来自 <u style="text-decoration-style:single">alarm</u>(2) 的超时信号
       <b>SIGTERM</b>      15       A     终止信号
       <b>SIGUSR1</b>   30,10,16    A     用户定义的信号 1
       <b>SIGUSR2</b>   31,12,17    A     用户定义的信号 2
       <b>SIGCHLD</b>   20,17,18    B     子进程结束或停止
       <b>SIGCONT</b>   19,18,25          继续停止的进程
       <b>SIGSTOP</b>   17,19,23   DEF    停止进程
       <b>SIGTSTP</b>   18,20,24    D     终端上发出的停止信号
       <b>SIGTTIN</b>   21,21,26    D     后台进程试图从控制终端(tty)输入
       <b>SIGTTOU</b>   22,22,27    D     后台进程试图在控制终端(tty)输出
</pre>

发送信号

### kill

```c

    #include<sys/types.h>
    #include<signal.h>
    
    int kill_t(pid_t pid, int sig);
	返回值： 成功返回0;
	失败返回-1;
```

### raise

```c
raise//发送信号给自己
    #include<signal.h>
    
    int raise(int sig);
	sig:表示要发送给自己的信号
```

### alarm 定时发送信号

```c
#include<unistd.h>

unsigned int alarm(unsigned int seconds);
//返回值：上一个闹钟的剩余时间
```

定时发送SIGALRM	14信号给自己

alarm(5);

......

alarm(10);

像这样多个alarm函数以**最后一个为准**

有一种特殊情况

alarm(0)//表面看是马上发送，其实是**取消闹钟**

### signal 捕捉信号

捕捉信号是为了**改变该信号的默认处理方式**

```c
#include <signal.h>

typedef void (*sighandler_t)(int);//函数指针类型

sighandler_t signal(int signum, sighandler_t handler);
```
signum：要捕捉的那个信号的值

handler：指针变量，有三种情况

1. SIG_IGN: 忽略该信号

2. SIG_DFL: 采取默认行为

3. **自定义该信号处理方式**

   通过函数指针去指定某个函数为收到该信号的处理方式

比如

```c
void func(int sig){
    
}
```

