# 0，网络通信

​	通信需要具备两个基本条件
​	(1)物理媒介（硬件层面）
​		光纤/网线
​	(2)协议（软件层面）
​	     网络协议




# 1，网络协议层次模型

​	把不同的功能封装成不同的功能模块，为什么不叫模块，而要叫层次
​	因为不同的模块可以相互调用，如果不能隔层调用，称之为层次会更加形象
​	

	有两个经典的标准， OSI七层模型和 tcp/ip 四层模型
	
	如画：
		OSI七层模型
			应用层
			表示层
			会话层
			传输层
			网络层
			数据链路层
			物理层


​		TCP/IP四层模型
​			应用层
​				应用层协议
​					DNS协议
​					http
​					QQ协议
​					.....
​					可以由程序自己决定（私有协议）
​		


		传输层
			主要作用是解决数据如何传输的问题
			协议： TCP		UDP
			TCP Transmission Control Protocol 传输层控制协议
				是一种面向连接的传输层协议，它能提供可靠的通信
				（数据无误，数据无丢失，数据无失序，数据无重复到达）的通信
				如何来保证这个可靠性的呢？
					-》
					建立连接
					“三次握手”
					“四次挥手”
					重发机制
					.....
					
			UDP User Datagram Protocol 用户数据报协议
				它是面向无连接的传输层协议。在数据发送前不需要建立连接
				所以可以进行高效率的数据传输
				
		网络层
			IP	<- 主要用的 IP 协议 internet Protocol
			IP地址(网络的逻辑地址)
		
		物理层(设备驱动和硬件)
			硬件：
				网卡，每个网卡在出厂的时候就有一个唯一的标识 :MAC地址
				网线
				
			MAC协议： 
				MAC地址(网卡的物理地址 48bit)，出厂时就固定了，唯一的
# 2，网络数据是如何传输的

​	1,保证物理上是连通的
​		以我们教室的局域网为例
​		如图：
​		

	2，协议
		TCP/IP 协议族
		
	分层传输
		数据封装  ，  拆包
		
	几个基本设备
		交换机
			扩展网口
			增强信号
		
		路由器
			主要功能是根据“路由表” 决定网络数据的 下一站
			
		猫：
			调制解调器


# 3，互联网地址（IP地址）

​	互联网上的每个接口(网卡)都必须有一个唯一的 internet 地址(也称之为IP地址)
​	协议上的一个逻辑地址，进行通信时，用这个IP地址唯一标识一台主机(一个网卡)
​	IPv4 :32bit
​	IPv6 :48bit
​	

	ipv4地址有32bit，那么怎么区分呢？
		一般把一个ipv4地址，分为两部分
		网段号和主机号 。就和生活中的座机电话号码一样
			区号和主机号
			如: 0731 8888888
	
		ipv4 
			网段号：用来标识某个网络
				在ip地址的连续高位
				
			主机号：用来标识特定网络中的特定的主机
				在ip地址的连续低位
				
		1110 0010 0100 0101 0010 1001 0111 1111 <-对人不友好，太难记了
		
		用点分式来表示
			每8bit用一个十进制数字表示，4个十进制数字，中间用 "." 隔开
			
			1110 0010  ——》226
			0100 0101	-》 69
			0010 1001	-》 41
			0111 1111	-》	127
		1110 0010 0100 0101 0010 1001 0111 1111用点分式表示为 226.69.41.127

| IP地址分类                        | IP地址范围                | 私有地址范围              |
| --------------------------------- | ------------------------- | ------------------------- |
| A类地址  0+7bit网段号+24Bit主机号 | 0.0.0.0 ~ 127.255.255.255 | 10.0.0.0 ~ 10.255.255.255 |
|B类地址 10+14bit网段号+16bit主机号 | 128.0.0.0 ~ 191.255.255.255 | 172.16.0.0 ~ 172.31.255.255 |
|C类地址 110+21bit网段号+8bit主机号 | 192.0.0.0 ~ 223.255.255.255 | 192.168.0.0 ~ 192.168.255.255 |
|D类地址(用于多播)	1110+多播组号(28bit) | 224.0.0.0 ~ 239.255.255.255 | |
|E类地址 11110开头 留待后用 | | |


​	在设置一个IP时，我们还可以指定这个地址中哪些bit是网段号，哪些Bit是主机号
​	
​	子网掩码(netmask)
​		就是用来指定一个ip地址中，哪些bit是网段号，哪些是主机号
​		
​		子网掩码和 ip地址的bit一致，子网掩码为1的bit为网段号，为0的bit为主机号
​		

		例子：
			有一个IP地址为 192.168.0.167，对应的子网掩码为255.255.0.0
					255.255.0.0	-> 11111111 11111111 00000000 00000000
			那么：
				IP地址中 bit16 ~ bit31 为网段号
						 bit0 ~ bit15 为主机号


​	
​			子网掩码255.127.0.0是否合法？？
​				11111111 01111111 00000000 00000000
​				不合法，因为网段号是连续的高位


​		练习：
​			某个网络的子网掩码是
​			255.224.0.0
​			
​			以下两个IP地址是否是属于同一个网络
​			
​			192.168.128.25
​			192.168.230.35


​			由子网掩码得知，网段号是 bit21 ~  bit31
​			两个IP地址的前11bit相同，说明是同一个网络
​	
​		windows中查询网络信息的指令 ipconfig
​		linux中查询网络信息的指令 ifconfig
​			配置IP和netmask的命令
​				ifconfig "网卡名" 你要设置的ip地址 netmask 你要设置的子网掩码 up
​				如:
​					ifconfig ens33 192.168.0.168 netmask 255.255.255.0 up


​	
​		练习：
​					255.255.255.0
​			IP地址 192.167.35.xxxxxxxx   C类地址  所以满足 110+21bit网段号+8bit主机号
​				
​			公司有4个部门，其中人数最多的部门为 50人
​				你可以把这个IP网络设置为4个子网
​				
​				拿两个主机号出来变为网段号
​	

				192.167.35.00xxxxxx
				192.167.35.01xxxxxx
				192.167.35.10xxxxxx
				192.167.35.11xxxxxx
				
				子网掩码设置为
				255.255.255.192
	
	ip地址用来唯一标识一台主机，但是一台主机上可能会同时运行多个网络程序。
	那么，假如有人给你的主机发送数据，你怎么知道他是发送给你的哪个应用程序？？
	
	这些应用程序可以根据传输层协议不同分为两类：UDP 和 TCP
	但是不管是TCP还是UDP，都可能有多个应用程序在你的主机上运行
	-》端口号

# 4，端口号

​	TCP/UDP 都采取 16bit的端口号来标识应用程序的
​	

	一台主机上的网络应用程序由： IP地址 + 传输层协议(TCP/UDP) + 端口号  确定
	
	端口号由 IANA（Internet Assigned Numbers Authority） 管理
		一些比较出名的应用程序占用的端口号
			1-1024
				http :21
				DNS :53
				.....
			尽量别用这些公共出名的端口号

# 5，网络字节序的问题

​	大小端
​	有些主机是大端模式，有些主机是小端模式
​			0x11	0x22	0x33	0x44
​			低地址					高地址
​		在大端模式主机A中，该数据的值	0x11223344
​		在小端模式主机B中，该数据的值	0x44332211
​	

		两种不同模式的主机进行网络通信，就会有问题了
	
		所以在网络传输中需要统一采取大端模式	-》 网络字节序
	
	用几个专门用于转化的函数
		#include <arpa/inet.h>
			h：host主机
			n: net网络
			l: 32位数据
			s: 16数据
		uint32_t htonl(uint32_t hostlong);
				把32位数据由主机字节序装换为网络字节序
			
		uint16_t htons(uint16_t hostshort);
				把16位数据由主机字节序装换为网络字节序
	
		uint32_t ntohl(uint32_t netlong);
				把32位数据由网络字节序装换为主机字节序
	
		uint16_t ntohs(uint16_t netshort);
				把16位数据由网络字节序装换为主机字节序


​	
​	
​	
​	
​	
​	